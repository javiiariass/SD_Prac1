/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "gestorAlmacenes.h"

// Variable global para el nombre del almacén actual
char nombre_almacen_actual[90] = "";

// Declaración de la función mostrar_menu
int mostrar_menu();

// Función supermercado_1 generada por rpcgen, comentada ya que no se usará directamente.
void
supermercado_1(char *host)
{
	/*
	CLIENT *clnt;
	TDatosAlmacen *result_1;
	int datosalmacen_1_arg;
	int *result_2;
	int nproductos_1_arg;
	int *result_3;
	TDatosAlmacen crearalmacen_1_arg;
	int *result_4;
	char abriralmacen_1_arg; // Debería ser Cadena? Revisar tipo original
	bool_t *result_5;
	int guardaralmacen_1_arg;
	bool_t *result_6;
	int cerraralmacen_1_arg;
	bool_t *result_7;
	int almacenabierto_1_arg;
	int *result_8;
	TBusProd buscaproducto_1_arg;
	TProducto *result_9;
	TObtProd obtenerproducto_1_arg;
	bool_t *result_10;
	TActProd anadirproducto_1_arg;
	bool_t *result_11; // Falta la llamada a ActualizarProducto
	TBusProd eliminarproducto_1_arg;
	TProducto *result_12; // Corresponde a operacion_1
	TOperacion operacion_1_arg;


#ifndef DEBUG
	clnt = clnt_create(host, SUPERMERCADO, SUPERMERCADO_VER, "udp"); // Originalmente UDP
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif // DEBUG //

	// ... llamadas RPC de ejemplo originales ...
	// result_1 = datosalmacen_1(&datosalmacen_1_arg, clnt);
	// ... etc ...

#ifndef DEBUG
	clnt_destroy(clnt);
#endif // DEBUG //
	*/
}

// Función principal del cliente
int main(int argc, char *argv[])
{
	char *host;
	CLIENT *clnt;
	int opcion;
	// Variable para almacenar el ID del almacén actual gestionado por este cliente
	int id_almacen_actual = -1; // -1 indica que no hay almacén abierto

	if (argc < 2)
	{
		printf("usage: %s server_host\n", argv[0]);
		exit(1);
	}
	host = argv[1];

	// Crear cliente RPC usando TCP
#ifndef DEBUG
	clnt = clnt_create(host, SUPERMERCADO, SUPERMERCADO_VER, "tcp"); // Cambiado a TCP
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */

	do
	{
		opcion = mostrar_menu();

		switch (opcion)
		{
		case 1:
			printf("Has elegido: Crear un almacén vacio\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida datos y llame a crearalmacen_1
			break;
		case 2:
			printf("Has elegido: Abrir un fichero de almacén\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida nombre fichero y llame a abriralmacen_1
			break;
		case 3:
			printf("Has elegido: Cerrar un almacén\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a cerraralmacen_1 si id_almacen_actual != -1
			break;
		case 4:
			printf("Has elegido: Guardar Datos\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a guardaralmacen_1 si id_almacen_actual != -1
			break;
		case 5:
			printf("Has elegido: Listar productos del almacén\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a nproductos_1 y luego bucle con obtenerproducto_1
			break;
		case 6:
			printf("Has elegido: Añadir un producto\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida datos producto y llame a anadirproducto_1
			break;
		case 7:
			printf("Has elegido: Actualizar un producto\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida código, busque, pida nuevos datos y llame a actualizarproducto_1
			break;
		case 8:
			printf("Has elegido: Consultar un producto\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida código, llame a buscaproducto_1 y obtenerproducto_1
			break;
		case 9:
			printf("Has elegido: Eliminar un producto\n");
			// Aquí irán las llamadas RPC correspondientes
			// Ejemplo: Llamar a una función local que pida código y llame a eliminarproducto_1
			break;
		case 0:
			printf("Saliendo del programa...\n");
			// Considerar cerrar el almacén si está abierto antes de salir?
			// if (id_almacen_actual != -1) { /* llamar a cerraralmacen_1 */ }
			break;
		default:
			printf("Opción no válida. Inténtalo de nuevo.\n");
			break;
		}

		// Pausa antes de volver a mostrar el menú (excepto si se elige salir)
		if (opcion != 0)
		{
			printf("\nPulsa Enter para continuar...");
			// Consumir el Enter pendiente del scanf anterior y esperar nuevo Enter
			// while (getchar() != '\n'); // Limpia buffer si quedó algo
			fflush(stdin); // Limpiamos buffer 
			getchar(); // Espera el Enter del usuario
			
		}

	} while (opcion != 0);

#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */

	exit(0);
}


// Definición de la función mostrar_menu
int mostrar_menu() {
    int opcion;

	// Limpiar pantalla 
	system("clear"); 

    printf("\n");
    printf("****************************************\n");
    // Mostrar el nombre del almacén actual si existe
    if (strlen(nombre_almacen_actual) > 0) {
        printf("--- Menú Almacenes --- %s ---\n", nombre_almacen_actual);
    } else {
        printf("--- Menú Almacenes --- (Ningún almacén abierto) ---\n");
    }
    printf("****************************************\n");
    printf("1. Crear un almacén vacio.\n");
    printf("2. Abrir un fichero de almacén.\n");
    printf("3. Cerrar un almacén.\n");
    printf("4. Guardar Datos.\n");
    printf("5. Listar productos del almacén.\n");
    printf("6. Añadir un producto.\n");
    printf("7. Actualizar un producto.\n");
    printf("8. Consultar un producto.\n");
    printf("9. Eliminar un producto.\n");
    printf("0. Salir.\n");
    printf("****************************************\n");
    printf("Introduce tu opción: ");

    // Leer la opción del usuario
    // Validar que se introduce un entero
    while (scanf("%d", &opcion) != 1) {
        printf("Entrada inválida. Introduce un número: ");
        // Limpiar el buffer de entrada
        //        while (getchar() != '\n');
        fflush(stdin);
    }

    // Limpiar el buffer del teclado después de leer el entero correctamente
    fflush(stdin);

    return opcion;
}